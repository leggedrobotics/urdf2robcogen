//
// Created by rgrandia on 23.09.19.
//

#include "urdf2robcogen/utils.hpp"

#include <kindr/Core>
#include <Eigen/Dense>

#include <ctime>
#include <fstream>

Eigen::Matrix3d inertiaMatrixFromLink(const urdf::LinkConstSharedPtr& link) {
  Eigen::Matrix3d inertia;

  inertia(0, 0) = link->inertial->ixx;
  inertia(1, 1) = link->inertial->iyy;
  inertia(2, 2) = link->inertial->izz;
  inertia(0, 1) = inertia(1, 0) = link->inertial->ixy;
  inertia(0, 2) = inertia(2, 0) = link->inertial->ixz;
  inertia(1, 2) = inertia(2, 1) = link->inertial->iyz;

  return inertia;
}

void assignInertiaToLink(const urdf::LinkSharedPtr& link, const Eigen::Matrix3d& inertia) {
  // sanity check on inertia
  assert(std::fabs(inertia(0, 1) - inertia(1, 0)) < 1e-6);
  assert(std::fabs(inertia(0, 2) - inertia(2, 0)) < 1e-6);
  assert(std::fabs(inertia(1, 2) - inertia(2, 1)) < 1e-6);

  Eigen::VectorXcd eigenvalues = inertia.eigenvalues();
  assert(eigenvalues.real().minCoeff() > 0.0 and eigenvalues.imag().cwiseAbs().maxCoeff() < 1e-9);

  link->inertial->ixx = inertia(0, 0);
  link->inertial->iyy = inertia(1, 1);
  link->inertial->izz = inertia(2, 2);
  link->inertial->ixy = inertia(0, 1);
  link->inertial->ixz = inertia(0, 2);
  link->inertial->iyz = inertia(1, 2);
}

Eigen::Matrix3d skewSymMatrixFromVector(const Eigen::Vector3d& vec) {
  Eigen::Matrix3d skew;
  skew << 0, -vec(2), vec(1),  // clang-format off
          vec(2), 0, -vec(0),
          -vec(1), vec(0), 0;  // clang-format on
  return skew;
}

Eigen::Vector3d toEigen(const urdf::Vector3& vec) {
  return {vec.x, vec.y, vec.z};
}

urdf::Vector3 fromEigen(const Eigen::Vector3d& vec){
  return {vec(0), vec(1), vec(2)};
}

Eigen::Quaterniond toEigen(const urdf::Rotation& rotation) {
  Eigen::Quaterniond q;
  rotation.getQuaternion(q.x(), q.y(), q.z(), q.w());
  return q;
}

urdf::Rotation fromEigen(const Eigen::Quaterniond& rotation) {
  return {rotation.x(), rotation.y(), rotation.z(), rotation.w()};
}

std::string printVector(const urdf::Vector3& vector) {
  constexpr double epsilon = 1e-6;

  auto numberAsString = [](const double in) {
    if (std::abs(in - M_PI) < epsilon) {
      return std::string{"PI"};
    } else if (std::abs(in + M_PI) < epsilon) {
      return std::string{"-PI"};
    } else if (std::abs(in - M_PI_2) < epsilon) {
      return std::string{"PI/2.0"};
    } else if (std::abs(in + M_PI_2) < epsilon) {
      return std::string{"-PI/2.0"};
    } else if (std::abs(in - M_PI_4) < epsilon) {
      return std::string{"PI/4.0"};
    } else if (std::abs(in + M_PI_4) < epsilon) {
      return std::string{"-PI/4.0"};
    } else {
      std::ostringstream value_as_string;
      value_as_string.precision(std::numeric_limits<double>::digits10);
      value_as_string << std::fixed << in;
      return value_as_string.str();
    }
  };

  std::ostringstream out;
  out << "(" << numberAsString(vector.x) << "," << numberAsString(vector.y) << "," << numberAsString(vector.z) << ")";
  return out.str();
}

urdf::Vector3 rotationXyz(const urdf::Rotation& rot_quaternion) {
  urdf::Vector3 rot_vec;
  Eigen::Matrix<double, 3, 1> p_min;
  kindr::RotationQuaternionD quat(rot_quaternion.w, rot_quaternion.x, rot_quaternion.y, rot_quaternion.z);

  kindr::EulerAnglesXyz<double> temp(quat);
  kindr::EulerAnglesXyz<double> xyz_unique = temp.getUnique();
  double x, y, z;
  double epsilon = 1e-4;
  std::fabs(xyz_unique.yaw()) < epsilon ? z = 0.0 : z = xyz_unique.yaw();
  std::fabs(xyz_unique.pitch()) < epsilon ? y = 0.0 : y = xyz_unique.pitch();
  std::fabs(xyz_unique.roll()) < epsilon ? x = 0.0 : x = xyz_unique.roll();

  rot_vec = urdf::Vector3(x, y, z);

  return rot_vec;
}

void print_timeStamp(std::ofstream& stream) {
  auto t = std::time(nullptr);
  auto tm = *std::localtime(&t);

  stream << "/*\n * Autogenerated by Urdf2RobCoGen on " << std::put_time(&tm, "%Y-%m-%d %H:%M:%S") << "\n * DO NOT EDIT BY HAND\n */\n"
         << "" << std::endl;
}